syntax = "proto3";

package messages_prost.sbg;

import "common.proto";

message Vector3 {
  float x = 1;
  float y = 2;
  float z = 3;
}

// From sbg.proto
enum EkfSolutionMode {
  EKF_SOLUTION_MODE_UNSPECIFIED = 0;
  UNINITIALIZED = 1;
  VERTICAL_GYRO = 2;
  AHRS = 3;
  NAV_VELOCITY = 4;
  NAV_POSITION = 5;
}

// Define the bitmask flags as an enum
enum EkfStatusFlag {
  option allow_alias = true;
  EKF_STATUS_NONE           = 0;
  EKF_STATUS_ATTITUDE_VALID = 1;      // 0x01
  EKF_STATUS_HEADING_VALID  = 2;      // 0x02
  EKF_STATUS_VELOCITY_VALID = 4;      // 0x04
  EKF_STATUS_POSITION_VALID = 8;      // 0x08
  EKF_STATUS_VERT_REF_USED  = 16;     // 0x10
  EKF_STATUS_MAG_REF_USED   = 32;     // 0x20
  EKF_STATUS_GPS1_VEL_USED  = 64;     // 0x40
  EKF_STATUS_GPS1_POS_USED  = 128;    // 0x80
  EKF_STATUS_GPS1_HDT_USED  = 256;    // 0x100
  EKF_STATUS_GPS2_VEL_USED  = 512;    // 0x200
  EKF_STATUS_GPS2_POS_USED  = 1024;   // 0x400
  EKF_STATUS_GPS2_HDT_USED  = 2048;   // 0x800
  EKF_STATUS_ODO_USED       = 4096;   // 0x1000
  EKF_STATUS_DVL_BT_USED    = 8192;   // 0x2000
  EKF_STATUS_DVL_WT_USED    = 16384;  // 0x4000
  EKF_STATUS_USER_POS_USED  = 32768;  // 0x8000
  EKF_STATUS_USER_VEL_USED  = 65536;  // 0x10000
  EKF_STATUS_USER_HEADING_USED = 131072; // 0x20000
  EKF_STATUS_USBL_USED      = 262144; // 0x40000
  EKF_STATUS_AIR_DATA_USED  = 524288; // 0x80000
  EKF_STATUS_ZUPT_USED      = 1048576; // 0x100000
  EKF_STATUS_ALIGN_VALID    = 2097152; // 0x200000
  EKF_STATUS_DEPTH_USED     = 4194304; // 0x400000
}

// Use a uint32 to store the bitmask, and keep the solution mode as a separate field
message EkfStatus {
  EkfSolutionMode solution_mode = 1;
  uint32 flags = 2; // Bitmask of EkfStatusFlag values.
}

enum ClockStatus {
  CLOCK_STATUS_UNSPECIFIED = 0;
  CLOCK_ERROR = 1;
  FREE_RUNNING = 2;
  STEERING = 3;
  CLOCK_VALID = 4;
}

enum UtcStatus {
  UTC_STATUS_UNSPECIFIED = 0;
  UTC_INVALID = 1;
  NO_LEAP_SEC = 2;
  UTC_VALID = 3;
}

message UtcTimeStatus {
  ClockStatus clock_status = 1;
  UtcStatus utc_status = 2;
}

message AirStatus {
  bool time_is_delay = 1;
  bool pressure_abs_valid = 2;
  bool altitude_valid = 3;
  bool pressure_diff_valid = 4;
  bool airspeed_valid = 5;
  bool temperature_valid = 6;
}

// Define the bitmask flags as an enum
enum ImuStatusFlag {
  option allow_alias = true;
  IMU_STATUS_NONE           = 0;
  IMU_STATUS_COM_OK         = 1;    // 0x01
  IMU_STATUS_TEST_PASS      = 2;    // 0x02
  IMU_STATUS_ACCEL_X_PASS   = 4;    // 0x04
  IMU_STATUS_ACCEL_Y_PASS   = 8;    // 0x08
  IMU_STATUS_ACCEL_Z_PASS   = 16;   // 0x10
  IMU_STATUS_GYRO_X_PASS    = 32;   // 0x20
  IMU_STATUS_GYRO_Y_PASS    = 64;   // 0x40
  IMU_STATUS_GYRO_Z_PASS    = 128;  // 0x80
  IMU_STATUS_ACCELS_IN_RANGE = 256; // 0x100
  IMU_STATUS_GYROS_IN_RANGE  = 512; // 0x200
}

// Use a uint32 to store the bitmask
message ImuStatus {
  uint32 flags = 1; // Bitmask of ImuStatusFlag values.
}

enum GpsPositionStatusE {
  GPS_POSITION_STATUS_E_UNSPECIFIED = 0;
  SOL_COMPUTED = 1;
  INSUFFICIENT_OBS = 2;
  GPS_INTERNAL_ERROR = 3;
  HEIGHT_LIMIT = 4;
}

enum GpsPositionType {
  GPS_POSITION_TYPE_UNSPECIFIED = 0;
  NO_SOLUTION = 1;
  UNKNOWN_TYPE = 2;
  SINGLE = 3;
  PSEUDO_RANGE_DIFF = 4;
  SBAS = 5;
  OMNI_STAR = 6;
  RTK_FLOAT = 7;
  RTK_INT = 8;
  PPP_FLOAT = 9;
  PPP_INT = 10;
  FIXED = 11;
}

message GpsPositionStatus {
    GpsPositionStatusE status = 1;
    GpsPositionType type = 2;
}

enum GpsVelStatusE {
  GPS_VEL_STATUS_E_UNSPECIFIED = 0;
  VEL_SOL_COMPUTED = 1;
  VEL_INSUFFICIENT_OBS = 2;
  VEL_INTERNAL_ERROR = 3;
  VEL_LIMIT = 4;
}

enum GpsVelType {
  GPS_VEL_TYPE_UNSPECIFIED = 0;
  VEL_NO_SOLUTION = 1;
  VEL_UNKNOWN_TYPE = 2;
  DOPPLER = 3;
  DIFFERENTIAL = 4;
}

message GpsVelStatus {
    GpsVelStatusE status = 1;
    GpsVelType type = 2;
}

message GpsPos {
    optional double latitude = 1;
    optional double longitude = 2;
    optional uint32 time_of_week = 3;
    optional float undulation = 4;
    optional double altitude = 5;
    uint32 time_stamp = 6;
    GpsPositionStatus status = 7;
    optional float latitude_accuracy = 8;
    optional float longitude_accuracy = 9;
    optional float altitude_accuracy = 10;
    optional uint32 num_sv_used = 11;
    optional uint32 base_station_id = 12;
    optional uint32 differential_age = 13;
}

message UtcTime {
    uint32 time_stamp = 1;
    UtcTimeStatus status = 2;
    optional uint32 year = 3;
    optional int32 month = 4;
    optional int32 day = 5;
    optional int32 hour = 6;
    optional int32 minute = 7;
    optional int32 second = 8;
    optional int32 nano_second = 9;
    optional uint32 gps_time_of_week = 10;
}

message Air {
    uint32 time_stamp = 1;
    AirStatus status = 2;
    optional float pressure_abs = 3;
    optional float altitude = 4;
    optional float pressure_diff = 5;
    optional float true_airspeed = 6;
    optional float air_temperature = 7;
}

message Quaternion {
  float w = 1;
  float x = 2;
  float y = 3;
  float z = 4;
}

message EkfQuat {
    uint32 time_stamp = 1;
    EkfStatus status = 2;
    optional Quaternion quaternion = 3;
    optional Vector3 euler_std_dev = 4;
}

message EkfNav {
    uint32 time_stamp = 1; // Time in us since the sensor power up.
    optional Vector3 velocity = 2; // North, East, Down velocity in m.s^-1. (length 3)
    optional Vector3 velocity_std_dev = 3; // North, East, Down velocity 1 sigma standard deviation in m.s^-1. (length 3)
    optional Vector3 position = 4; // Latitude, Longitude in degrees positive North and East. Altitude above MSL in meters. (length 3)
    optional float undulation = 5; // Altitude difference between the geoid and the Ellipsoid in meters.
    optional Vector3 position_std_dev = 6; // Latitude, longitude and altitude 1 sigma standard deviation in meters. (length 3)
    optional EkfStatus status = 7; // EKF solution status bitmask and enum.
}

message Imu {
    uint32 time_stamp = 1;
    ImuStatus status = 2;
    optional Vector3 accelerometers = 3;
    optional Vector3 gyroscopes = 4;
    optional float temperature = 5;
    optional Vector3 delta_velocity = 6;
    optional Vector3 delta_angle = 7;
}

message GpsVel {
    uint32 time_stamp = 1; // Time in us since the sensor power up.
    optional GpsVelStatus status = 2; // GPS velocity status, type and bitmask.
    optional uint32 time_of_week = 3; // GPS time of week in ms.
    optional Vector3 velocity = 4; // GPS North, East, Down velocity in m.s^-1. (length 3)
    optional Vector3 velocity_acc = 5; // GPS North, East, Down velocity 1 sigma accuracy in m.s^-1. (length 3)
    optional float course = 6; // Track ground course in degrees.
    optional float course_acc = 7; // Course accuracy in degrees.
}

message SbgData {
  oneof data {
    GpsPos gps_pos = 1;
    UtcTime utc_time = 2;
    Imu imu = 3;
    EkfQuat ekf_quat = 4;
    EkfNav ekf_nav = 5;
    GpsVel gps_vel = 6;
    Air air = 7;
  }
}

message SbgMessage {
    common.Node node = 1; 
    SbgData data = 2; 
}